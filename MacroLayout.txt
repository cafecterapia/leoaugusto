The Architectural Blueprint: Defining Page Zones with Grid Areas
Your primary macro layout should be defined by creating named zones, not by positioning individual elements. On your main page container (e.g., <body> or a wrapper <div>), you use display: grid and then grid-template-areas to draw a visual representation of your layout. For example: grid-template-areas: "header header" "sidebar main" "footer footer";. This single property establishes the entire high-level structure. You then assign your main sectioning elements (<header>, <main>, <aside>) to these named areas with the grid-area property (e.g., header { grid-area: header; }). This approach makes the overall page architecture immediately understandable and trivial to modify for different breakpoints by simply redefining the grid-template-areas string.
The Intrinsic Grid: Creating Self-Adjusting Column Layouts
For sections of your page that hold a collection of items, like a blog feed or product listing, the macro layout should adapt the number of columns automatically without media queries. This is achieved by setting the columns with a rule like grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));. This command instructs the browser to create as many columns as will fit, ensuring each is at a minimum 350px wide. If there's extra space, auto-fit collapses any empty tracks and the 1fr unit tells the existing columns to grow and absorb that space equally. This creates a fluid, intrinsically responsive foundation that reflows based on available width, not fixed device breakpoints.
The Inherited Blueprint: Aligning Nested Items with Subgrid
When a major component within your layout needs its own internal grid, it should inherit the primary page grid's structure to maintain perfect alignment. You achieve this by setting grid-template-columns: subgrid on that component. This prevents the component from creating its own arbitrary column tracks. Instead, it "borrows" the grid lines from its parent. The result is that elements deep inside the component's HTML structure can be precisely aligned to the main page columns, solving complex alignment problems for things like forms, cards, or data tables that must appear visually consistent and locked into the overall page structure.
The Direction-Agnostic Layout: Building with Logical Properties
Your entire macro layout should be constructed to be independent of physical direction (left-to-right). Instead of using properties like margin-left or padding-right, you must exclusively use their logical equivalents: margin-inline-start, padding-inline-end, border-block-start, etc. Inline refers to the direction text flows (left-right or right-left), and block refers to the direction lines stack (top-bottom). By using these properties for all spacing, borders, and alignment on your main grid containers and areas, the entire page layout will automatically and correctly adapt to different writing modes, such as right-to-left languages, without requiring any additional CSS.
 It uses viewport-based media queries (@media). Do not use @container queries on the macro
 Do not add whole paregraphs on the global css especifically for a section. It's global for a reasoning
 We are using tailwind v4. the tailwind.config.ts is minimal as it should be and the semantic colors stay on the global css